# 反射

## 57.什么是反射？

反射机制指的是程序在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。

- 获取一个Class对象
- 实例化一个Class表示的类的对象
- 获取构造方法
- 获取成员变量
- 获取成员方法

## 58.什么是 java 序列化？什么情况下需要序列化？

序列化：将 Java 对象转换成字节流的过程。

反序列化：将字节流转换成 Java 对象的过程。

当 Java 对象需要在网络上传输 或者 持久化存储到文件中时，就需要对 Java 对象进行序列化处理。

序列化的实现：类实现 Serializable 接口，这个接口没有需要实现的方法。实现 Serializable 接口是为了告诉 jvm 这个类的对象可以被序列化。

注意事项：

- 某个类可以被序列化，则其子类也可以被序列化
- 声明为 static 和 transient 的成员变量，不能被序列化。static 成员变量是描述类级别的属性，transient 表示临时数据
- 反序列化读取序列化对象的顺序要保持一致

具体使用

```java
package constxiong.interview;
 
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
 
/**
 * 测试序列化，反序列化
 * @date 2019-06-17 09:31:22
 */
public class TestSerializable implements Serializable {
 
	private static final long serialVersionUID = 5887391604554532906L;
	
	private int id;
	
	private String name;
 
	public TestSerializable(int id, String name) {
		this.id = id;
		this.name = name;
	}
	
	@Override
	public String toString() {
		return "TestSerializable [id=" + id + ", name=" + name + "]";
	}
 
	@SuppressWarnings("resource")
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		//序列化
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("TestSerializable.obj"));
		oos.writeObject("测试序列化");
		oos.writeObject(618);
		TestSerializable test = new TestSerializable(1, "ConstXiong");
		oos.writeObject(test);
		
		//反序列化
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("TestSerializable.obj"));
		System.out.println((String)ois.readObject());
		System.out.println((Integer)ois.readObject());
		System.out.println((TestSerializable)ois.readObject());
	}
 
}
```

打印结果：

```
测试序列化
618
TestSerializable [id=1, name=ConstXiong]
```

## 59.动态代理是什么？有哪些应用？

动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。

动态代理的应用：Spring的AOP，加事务，加权限，加日志。

## 60.怎么实现动态代理？

首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。

# 对象拷贝

## 61.为什么要使用克隆？

想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了。

克隆分浅克隆和深克隆，浅克隆后的对象中非基本对象和原对象指向同一块内存，因此对这些非基本对象的修改会同时更改克隆前后的对象。深克隆可以实现完全的克隆，可以用反射的方式或序列化的方式实现。

## 62.如何实现对象克隆？

- 实现 Cloneable 接口，重写 clone() 方法。
- 不实现 Cloneable 接口，会报 CloneNotSupportedException 异常。

```java
package constxiong.interview;
 
/**
 * 测试克隆
 * @author ConstXiong
 * @date 2019-06-18 11:21:21
 */
public class TestClone {
 
	public static void main(String[] args) throws CloneNotSupportedException {
		Person p1 = new Person(1, "ConstXiong");//创建对象 Person p1
		Person p2 = (Person)p1.clone();//克隆对象 p1
		p2.setName("其不答");//修改 p2的name属性，p1的name未变
		System.out.println(p1);
		System.out.println(p2);
	}
	
}
 
/**
 * 人
 * @author ConstXiong
 * @date 2019-06-18 11:54:35
 */
class Person implements Cloneable {
	
	private int pid;
	
	private String name;
	
	public Person(int pid, String name) {
		this.pid = pid;
		this.name = name;
		System.out.println("Person constructor call");
	}
 
	public int getPid() {
		return pid;
	}
 
	public void setPid(int pid) {
		this.pid = pid;
	}
 
	public String getName() {
		return name;
	}
 
	public void setName(String name) {
		this.name = name;
	}
 
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
 
	@Override
	public String toString() {
		return "Person [pid:"+pid+", name:"+name+"]";
	}
	
}
```

打印结果：

```
Person constructor call
Person [pid:1, name:ConstXiong]
Person [pid:1, name:其不答]
```

 

- Object 的 clone() 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。

 

可以使用下面的两种方法，完成 Person 对象的深拷贝。

方法1、对象的属性的Class 也实现 Cloneable 接口，在克隆对象时也手动克隆属性。

```java
  
    @Override
	public Object clone() throws CloneNotSupportedException {
		DPerson p = (DPerson)super.clone();
		p.setFood((DFood)p.getFood().clone());
		return p;
	}
 
```

完整代码：

```java
package constxiong.interview;
 
/**
 * 测试克隆
 * @author ConstXiong
 * @date 2019-06-18 11:21:21
 */
public class TestManalDeepClone {
 
	public static void main(String[] args) throws Exception {
		DPerson p1 = new DPerson(1, "ConstXiong", new DFood("米饭"));//创建Person 对象 p1
		DPerson p2 = (DPerson)p1.clone();//克隆p1
		p2.setName("其不答");//修改p2的name属性
		p2.getFood().setName("面条");//修改p2的自定义引用类型 food 属性
		System.out.println(p1);//修改p2的自定义引用类型 food 属性被改变，p1的自定义引用类型 food 属性也随之改变，说明p2的food属性，只拷贝了引用，没有拷贝food对象
		System.out.println(p2);
	}
	
}
 
class DPerson implements Cloneable {
	
	private int pid;
	
	private String name;
	
	private DFood food;
	
	public DPerson(int pid, String name, DFood food) {
		this.pid = pid;
		this.name = name;
		this.food = food;
		System.out.println("Person constructor call");
	}
 
	public int getPid() {
		return pid;
	}
 
	public void setPid(int pid) {
		this.pid = pid;
	}
 
	public String getName() {
		return name;
	}
 
	public void setName(String name) {
		this.name = name;
	}
 
	@Override
	public Object clone() throws CloneNotSupportedException {
		DPerson p = (DPerson)super.clone();
		p.setFood((DFood)p.getFood().clone());
		return p;
	}
 
	@Override
	public String toString() {
		return "Person [pid:"+pid+", name:"+name+", food:"+food.getName()+"]";
	}
 
	public DFood getFood() {
		return food;
	}
 
	public void setFood(DFood food) {
		this.food = food;
	}
	
}
 
class DFood implements Cloneable{
	
	private String name;
	
	public DFood(String name) {
		this.name = name;
	}
 
	public String getName() {
		return name;
	}
 
	public void setName(String name) {
		this.name = name;
	}
 
	@Override
	public Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	
}
```

打印结果：

```
Person constructor call
Person [pid:1, name:ConstXiong, food:米饭]
Person [pid:1, name:其不答, food:面条]
```

 

方法2、结合序列化(JDK java.io.Serializable 接口、JSON格式、XML格式等)，完成深拷贝

结合 java.io.Serializable 接口，完成深拷贝

```java
package constxiong.interview;
 
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
 
public class TestSeriazableClone {
 
	public static void main(String[] args) {
		SPerson p1 = new SPerson(1, "ConstXiong", new SFood("米饭"));//创建 SPerson 对象 p1
		SPerson p2 = (SPerson)p1.cloneBySerializable();//克隆 p1
		p2.setName("其不答");//修改 p2 的 name 属性
		p2.getFood().setName("面条");//修改 p2 的自定义引用类型 food 属性
		System.out.println(p1);//修改 p2 的自定义引用类型 food 属性被改变，p1的自定义引用类型 food 属性未随之改变，说明p2的food属性，只拷贝了引用和 food 对象
		System.out.println(p2);
	}
	
}
 
class SPerson implements Cloneable, Serializable {
	
	private static final long serialVersionUID = -7710144514831611031L;
 
	private int pid;
	
	private String name;
	
	private SFood food;
	
	public SPerson(int pid, String name, SFood food) {
		this.pid = pid;
		this.name = name;
		this.food = food;
		System.out.println("Person constructor call");
	}
 
	public int getPid() {
		return pid;
	}
 
	public void setPid(int pid) {
		this.pid = pid;
	}
 
	public String getName() {
		return name;
	}
 
	public void setName(String name) {
		this.name = name;
	}
 
	/**
	 * 通过序列化完成克隆
	 * @return
	 */
	public Object cloneBySerializable() {
		Object obj = null;
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			ObjectOutputStream oos = new ObjectOutputStream(baos);
			oos.writeObject(this);
			ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
			ObjectInputStream ois = new ObjectInputStream(bais);
			obj = ois.readObject();
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return obj;
	}
 
	@Override
	public String toString() {
		return "Person [pid:"+pid+", name:"+name+", food:"+food.getName()+"]";
	}
 
	public SFood getFood() {
		return food;
	}
 
	public void setFood(SFood food) {
		this.food = food;
	}
	
}
 
class SFood implements Serializable {
	
	private static final long serialVersionUID = -3443815804346831432L;
	
	private String name;
	
	public SFood(String name) {
		this.name = name;
	}
 
	public String getName() {
		return name;
	}
 
	public void setName(String name) {
		this.name = name;
	}
	
}
```

打印结果：

```
Person constructor call
Person [pid:1, name:ConstXiong, food:米饭]
Person [pid:1, name:其不答, food:面条]
```

 

## 63.深拷贝和浅拷贝区别是什么？

复制一个 Java 对象
浅拷贝：复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针，不复制堆内存中的对象。

![img](https://img-blog.csdnimg.cn/20190618153224322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21laXNtNQ==,size_16,color_FFFFFF,t_70)

深拷贝：复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针和堆内存中的对象。

![img](https://img-blog.csdnimg.cn/20190618154423857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21laXNtNQ==,size_16,color_FFFFFF,t_70)